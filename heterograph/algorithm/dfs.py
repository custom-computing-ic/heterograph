import graph_tool.search as gs
import copy
from inspect import signature

class StopSearch(gs.StopSearch):
   pass

def get_paths(g, vs=None):
   """
   Returns all DFS paths in the graph `g` starting from the given vertices `vs`.

   Args:
      g (Graph): The graph to search for paths.
      vs (list or None): The starting vertices. If None, then graph source vertices will be considered.

   Returns:
      list: A list of paths generated by DFS, where each path is represented as a list of vertices.

   Example:
      >>> from heterograph.algorithm.dfs import get_paths
      >>> from heterograph import *
      >>> g = HGraph()
      >>> g.add_vx(5)
      [0, 1, 2, 3, 4]
      >>> g.add_edge(0, 1)
      [(0, 1)]
      >>> g.add_edge(1, [2, 3])
      [(1, 2), (1, 3)]
      >>> g.add_edge([2, 3], 4)
      [(2, 4), (3, 4)]
      >>> get_paths(g, vs=[0, 2])
      [[0, 1, 2, 4], [0, 1, 3, 4], [2, 4]]
   """
   class GetPath:
      @staticmethod
      def pre(g, vx, path, data):
         data.last_pre_vx = vx

      @staticmethod
      def post(g, vx, path, data):
         # leaf!
         if data.last_pre_vx == vx:
            data.paths.append(path+[vx])

      def __init__(self, g, vs=None):
         self.paths=[]
         dfs_visitor(g, vs, pre=GetPath.pre, post=GetPath.post, data=self)

   gp = GetPath(g, vs)
   return gp.paths

def dfs_visitor(g, vs=None, pre=None, post=None, data=None):
   """
   Depth-first search to find all paths in a graph. User supplied functions `pre` and `post` can gracefully stop execution by raising StopSearch. Data can be optionally shared when visiting nodes.

   Args:
      g (HGraph): The graph to perform the depth-first search on.
      vs (list, optional): The starting vertices for the search. If not provided, the source vertices of the graph will be used.
      pre (function, optional): A function to be called before visiting each vertex. It takes four arguments: the graph, the current vertex, the current path, and the additional data.
      post (function, optional): A function to be called after visiting each vertex. It takes four arguments: the graph, the current vertex, the current path, and the additional data.
      data (any, optional): Additional data to be passed to the pre and post functions.

   Returns:
      Does not return anything.

   Examples:
      >>> from heterograph.algorithm.dfs import dfs_visitor
      >>> from heterograph import *
      >>> g = HGraph()
      >>> g.add_vx(5)
      [0, 1, 2, 3, 4]
      >>> g.add_edge(0, 1)
      [(0, 1)]
      >>> g.add_edge(1, [2, 3])
      [(1, 2), (1, 3)]
      >>> g.add_edge([2, 3], 4)
      [(2, 4), (3, 4)]
      >>> def pre(g, vx, path, data):
      ...   print(f"Hello vertex {vx}")
      >>> def post(g, vx, path, data):
      ...   print(f"Bye vertex {vx}")
      >>> dfs_visitor(g, [0], pre=pre, post=post)
      Hello vertex 0
      Hello vertex 1
      Hello vertex 2
      Hello vertex 4
      Bye vertex 4
      Bye vertex 2
      Hello vertex 3
      Hello vertex 4
      Bye vertex 4
      Bye vertex 3
      Bye vertex 1
      Bye vertex 0
   """

   def __dfs_visitor(g, vx, pre, post, path, data):
      if pre is not None:
         pre(g, vx, path, data)

      upath = path.copy()
      upath.append(vx)
      for c_vx in g.out_vx(vx):
         __dfs_visitor(g, c_vx, pre, post, upath, data)

      if post is not None:
         post(g, vx, path, data)

   path = []
   if vs is None:
      vs = g.source

   if pre is None and post is None:
      raise RuntimeError("[x] must specify either pre or post function!")

   try:
      for vx in vs:
         __dfs_visitor(g, vx, pre=pre, post=post, path=path, data=data)
   except StopSearch:
      pass

def dfs_traversal(g, vx, pre=None, post=None, inh=None):
   """
   Perform a depth-first search (DFS) traversal of a graph starting from a given vertex.

   Args:
      g (HGraph): The graph on which to perform the DFS traversal.
      vx (int): The starting vertex for the DFS traversal.
      pre (function, optional): A function to be called before visiting each vertex's children.
         It takes two arguments: the graph `g` and the current vertex `vx`.
         An optional third argument `inh` can be added to receive inherited data. Defaults to None.
      post (function, optional): A function to be called after visiting each vertex's children.
         It takes two arguments: the graph `g` and the current vertex `vx`.
         An optional third argument `synth` can be added to receive synthesized data from its direct children. Defaults to None.
      inh (any, optional): Data to be inherited by each vertex. Defaults to None.

   Returns:
      Any: The synthesized data for the starting vertex, if a `post` function is provided and returns a value.

   Note:
      - The `dfs_traversal` function should be used instead of `dfs_visitor` to support sharing data between parent and child nodes (inheritance and/or synthesis). Furthermore, `dfs_traversal` is more efficient than `dfs_visit` and may perform better with larger graphs.
      - The `pre` function is always invoked before visiting children. If data is returned, it will be inherited by its children through the `inh` parameter.
      - The `post` function is always invoked after visiting children. It can optionally return data, which is aggregated into a list and passed to the parent as the `synth` parameter.
      - The `pre` and `post` functions can raise `StopSearch` to halt the search.
      - In the example below, the `pre` function uses inherited data to assign depth to a child vertex, while the `post` function uses synthesized data to count the number of visited vertices.
   ""

   Example:
      >>> from heterograph import HGraph
      >>> from heterograph.algorithm.dfs import dfs_traversal
      >>> def pre_visit(g, vx, inh):
      ...   print(f"Pre-visit: {vx}, inherited: {inh}")
      ...   return inh + 1
      >>> def post_visit(g, vx, synth):
      ...   print(f"Post-visit: {vx}, synthesized: {synth}")
      ...   return sum(synth) + 1

      >>> g = HGraph()
      >>> g.add_vx(5)
      [0, 1, 2, 3, 4]
      >>> g.add_edge(0, [1, 2])
      [(0, 1), (0, 2)]
      >>> g.add_edge(1, 3)
      [(1, 3)]
      >>> g.add_edge(2, 4)
      [(2, 4)]
      >>> num_vs = dfs_traversal(g, 0, pre=pre_visit, post=post_visit, inh=0)
      Pre-visit: 0, inherited: 0
      Pre-visit: 1, inherited: 1
      Pre-visit: 3, inherited: 2
      Post-visit: 3, synthesized: []
      Post-visit: 1, synthesized: [1]
      Pre-visit: 2, inherited: 1
      Pre-visit: 4, inherited: 2
      Post-visit: 4, synthesized: []
      Post-visit: 2, synthesized: [1]
      Post-visit: 0, synthesized: [2, 2]

      >>> print(num_vs)
      5
   """
   class Visitor(gs.DFSVisitor):
      # properties: pre is always invoked before visiting children
      #             post is always invoked after visiting children
      def __init__(self, g, pre, post, root_inh):
         self.g = g
         self.pre = pre
         self.post = post

         self.synth = None
         if self.post:
            sig = signature(self.post)
            if len(sig.parameters) == 3:
               # vx -> synthesised data
               self.synth = {}

         self.inh = None
         if self.pre:
            sig = signature(self.pre)
            if len(sig.parameters) == 3:
               # vx -> produced data to be inherited
               self.inh = {}
               self.root_inh = root_inh
               self.src_vx = None

      def tree_edge(self, e):
         if self.inh is not None:
            # stores last source
            self.src_vx = self.g.to_vx[int(e.source())]

      def discover_vertex(self, u):
         if self.pre:
            if self.inh is not None:
               if self.src_vx is not None:
                  inh = self.inh.get(self.src_vx, None)
               else:
                  inh = self.root_inh
               vx = self.g.to_vx[int(u)]
               ret = self.pre(g=self.g, vx=vx, inh=inh)
               self.inh[vx] = ret
            else:
               self.pre(g=self.g, vx=self.g.to_vx[int(u)])

      # all out-edges have been visited
      def finish_vertex(self, u):
         if self.post:
            vx = self.g.to_vx[int(u)]
            if self.synth is not None:
               synth_data = []
               for v_child in self.g.out_vx(vx):
                  synth_data.append(self.synth.get(v_child, None))
               ret = self.post(g=self.g, vx=vx, synth=synth_data)
               self.synth[vx] = ret
            else:
               self.post(g=self.g, vx=vx)


   if pre is None and post is None:
      raise RuntimeError("[x] must specify either pre or post function!")

   visitor = Visitor(g=g, pre=pre, post=post, root_inh=inh)

   g.check_vx(vx, verify=True)

   ivx = g.to_ivx[vx]
   gs.dfs_search(g=g.igraph, source=ivx, visitor=visitor)

   if visitor.synth:
      return visitor.synth[vx]
