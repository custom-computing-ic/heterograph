heterograph.algorithm.dfs
=========================

.. py:module:: heterograph.algorithm.dfs


Exceptions
----------

.. autoapisummary::

   heterograph.algorithm.dfs.StopSearch


Functions
---------

.. autoapisummary::

   heterograph.algorithm.dfs.get_paths
   heterograph.algorithm.dfs.dfs_visitor
   heterograph.algorithm.dfs.dfs_traversal


Module Contents
---------------

.. py:exception:: StopSearch

   Bases: :py:obj:`graph_tool.search.StopSearch`


   If this exception is raised from inside any search visitor object, the search is aborted.


   .. py:class:: __cause__

      exception cause



   .. py:class:: __context__

      exception context



   .. py:method:: __delattr__()

      Implement delattr(self, name).



   .. py:method:: __dir__()

      Default dir() implementation.



   .. py:method:: __eq__()

      Return self==value.



   .. py:method:: __format__()

      Default object formatter.

      Return str(self) if format_spec is empty. Raise TypeError otherwise.



   .. py:method:: __ge__()

      Return self>=value.



   .. py:method:: __getattribute__()

      Return getattr(self, name).



   .. py:method:: __getstate__()

      Helper for pickle.



   .. py:method:: __gt__()

      Return self>value.



   .. py:method:: __hash__()

      Return hash(self).



   .. py:method:: __init__()

      Initialize self.  See help(type(self)) for accurate signature.



   .. py:method:: __le__()

      Return self<=value.



   .. py:method:: __lt__()

      Return self<value.



   .. py:method:: __ne__()

      Return self!=value.



   .. py:method:: __new__()

      Create and return a new object.  See help(type) for accurate signature.



   .. py:method:: __reduce__()


   .. py:method:: __reduce_ex__()

      Helper for pickle.



   .. py:method:: __repr__()

      Return repr(self).



   .. py:method:: __setattr__()

      Implement setattr(self, name, value).



   .. py:method:: __setstate__()


   .. py:method:: __sizeof__()

      Size of object in memory, in bytes.



   .. py:method:: __str__()

      Return str(self).



   .. py:method:: __subclasshook__()

      Abstract classes can override this to customize issubclass().

      This is invoked early on by abc.ABCMeta.__subclasscheck__().
      It should return True, False or NotImplemented.  If it returns
      NotImplemented, the normal algorithm is used.  Otherwise, it
      overrides the normal algorithm (and the outcome is cached).



   .. py:class:: __suppress_context__


   .. py:class:: __traceback__


   .. py:method:: add_note()

      Exception.add_note(note) --
      add a note to the exception



   .. py:class:: args


   .. py:method:: with_traceback()

      Exception.with_traceback(tb) --
      set self.__traceback__ to tb and return self.



.. py:function:: get_paths(g, vs=None)

   Returns all DFS paths in the graph `g` starting from the given vertices `vs`.

   :param g: The graph to search for paths.
   :type g: Graph
   :param vs: The starting vertices. If None, then graph source vertices will be considered.
   :type vs: list or None

   :returns: A list of paths generated by DFS, where each path is represented as a list of vertices.
   :rtype: list

   .. rubric:: Example

   >>> from heterograph.algorithm.dfs import get_paths
   >>> from heterograph import *
   >>> g = HGraph()
   >>> g.add_vx(5)
   [0, 1, 2, 3, 4]
   >>> g.add_edge(0, 1)
   [(0, 1)]
   >>> g.add_edge(1, [2, 3])
   [(1, 2), (1, 3)]
   >>> g.add_edge([2, 3], 4)
   [(2, 4), (3, 4)]
   >>> get_paths(g, vs=[0, 2])
   [[0, 1, 2, 4], [0, 1, 3, 4], [2, 4]]


.. py:function:: dfs_visitor(g, vs=None, pre=None, post=None, data=None)

   Depth-first search to find all paths in a graph. User supplied functions `pre` and `post` can gracefully stop execution by raising StopSearch. Data can be optionally shared when visiting nodes.

   :param g: The graph to perform the depth-first search on.
   :type g: HGraph
   :param vs: The starting vertices for the search. If not provided, the source vertices of the graph will be used.
   :type vs: list, optional
   :param pre: A function to be called before visiting each vertex. It takes four arguments: the graph, the current vertex, the current path, and the additional data.
   :type pre: function, optional
   :param post: A function to be called after visiting each vertex. It takes four arguments: the graph, the current vertex, the current path, and the additional data.
   :type post: function, optional
   :param data: Additional data to be passed to the pre and post functions.
   :type data: any, optional

   :returns: Does not return anything.

   .. rubric:: Examples

   >>> from heterograph.algorithm.dfs import dfs_visitor
   >>> from heterograph import *
   >>> g = HGraph()
   >>> g.add_vx(5)
   [0, 1, 2, 3, 4]
   >>> g.add_edge(0, 1)
   [(0, 1)]
   >>> g.add_edge(1, [2, 3])
   [(1, 2), (1, 3)]
   >>> g.add_edge([2, 3], 4)
   [(2, 4), (3, 4)]
   >>> def pre(g, vx, path, data):
   ...   print(f"Hello vertex {vx}")
   >>> def post(g, vx, path, data):
   ...   print(f"Bye vertex {vx}")
   >>> dfs_visitor(g, [0], pre=pre, post=post)
   Hello vertex 0
   Hello vertex 1
   Hello vertex 2
   Hello vertex 4
   Bye vertex 4
   Bye vertex 2
   Hello vertex 3
   Hello vertex 4
   Bye vertex 4
   Bye vertex 3
   Bye vertex 1
   Bye vertex 0


.. py:function:: dfs_traversal(g, vx, pre=None, post=None, inh=None)

   Perform a depth-first search (DFS) traversal of a graph starting from a given vertex.

   :param g: The graph on which to perform the DFS traversal.
   :type g: HGraph
   :param vx: The starting vertex for the DFS traversal.
   :type vx: int
   :param pre: A function to be called before visiting each vertex's children.
               It takes two arguments: the graph `g` and the current vertex `vx`.
               An optional third argument `inh` can be added to receive inherited data. Defaults to None.
   :type pre: function, optional
   :param post: A function to be called after visiting each vertex's children.
                It takes two arguments: the graph `g` and the current vertex `vx`.
                An optional third argument `synth` can be added to receive synthesized data from its direct children. Defaults to None.
   :type post: function, optional
   :param inh: Data to be inherited by each vertex. Defaults to None.
   :type inh: any, optional

   :returns: The synthesized data for the starting vertex, if a `post` function is provided and returns a value.
   :rtype: Any

   .. note::

      - The `dfs_traversal` function should be used instead of `dfs_visitor` to support sharing data between parent and child nodes (inheritance and/or synthesis). Furthermore, `dfs_traversal` is more efficient than `dfs_visit` and may perform better with larger graphs.
      - The `pre` function is always invoked before visiting children. If data is returned, it will be inherited by its children through the `inh` parameter.
      - The `post` function is always invoked after visiting children. It can optionally return data, which is aggregated into a list and passed to the parent as the `synth` parameter.
      - The `pre` and `post` functions can raise `StopSearch` to halt the search.
      - In the example below, the `pre` function uses inherited data to assign depth to a child vertex, while the `post` function uses synthesized data to count the number of visited vertices.

   ""

   .. rubric:: Example

   >>> from heterograph import HGraph
   >>> from heterograph.algorithm.dfs import dfs_traversal
   >>> def pre_visit(g, vx, inh):
   ...   print(f"Pre-visit: {vx}, inherited: {inh}")
   ...   return inh + 1
   >>> def post_visit(g, vx, synth):
   ...   print(f"Post-visit: {vx}, synthesized: {synth}")
   ...   return sum(synth) + 1

   >>> g = HGraph()
   >>> g.add_vx(5)
   [0, 1, 2, 3, 4]
   >>> g.add_edge(0, [1, 2])
   [(0, 1), (0, 2)]
   >>> g.add_edge(1, 3)
   [(1, 3)]
   >>> g.add_edge(2, 4)
   [(2, 4)]
   >>> num_vs = dfs_traversal(g, 0, pre=pre_visit, post=post_visit, inh=0)
   Pre-visit: 0, inherited: 0
   Pre-visit: 1, inherited: 1
   Pre-visit: 3, inherited: 2
   Post-visit: 3, synthesized: []
   Post-visit: 1, synthesized: [1]
   Pre-visit: 2, inherited: 1
   Pre-visit: 4, inherited: 2
   Post-visit: 4, synthesized: []
   Post-visit: 2, synthesized: [1]
   Post-visit: 0, synthesized: [2, 2]

   >>> print(num_vs)
   5


